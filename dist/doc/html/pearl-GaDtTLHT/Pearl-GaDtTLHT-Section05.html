<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Pearl.GaDtTLHT.Section05</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Pearl-GaDtTLHT-Section05.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">pearl-GaDtTLHT-0.9.5: A Functional Pearl: Generalising and Dualising the third list-homomorphism theorem.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Portability</th><td>portable (ViewPatterns, PatternGuards)</td></tr><tr><th>Stability</th><td>stable</td></tr><tr><th>Maintainer</th><td>Drew Day &lt;drewday@gmail.com&gt;</td></tr><tr><th>Safe Haskell</th><td>Safe-Infered</td></tr></table><p class="caption">Pearl.GaDtTLHT.Section05</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">the current tree as the left child
</a></li><li><a href="#g:2"><code>v r</code> the seed for the right child
</a></li><li><a href="#g:3">and <code>v'</code> the seed going up. 
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc empty">&nbsp;</div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:t07">t07</a> ::  theorem [on relations]</li><li class="src short"><a href="#v:t07proof">t07proof</a> ::  theorem proof [t07] [on relations]</li><li class="src short"><a href="#v:t07comments">t07comments</a> ::  theorem comments [t07]</li><li class="src short"><a href="#v:p11">p11</a> ::  property</li><li class="src short"><a href="#v:p12">p12</a> ::  property</li><li class="src short"><a href="#v:test55">test55</a> ::  a</li><li class="src short"><a href="#v:p13">p13</a> ::  property</li><li class="src short"><a href="#v:p14">p14</a> ::  property</li><li class="src short"><a href="#v:p15">p15</a> ::  property</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a name="v:t07" class="def">t07</a> ::  theorem [on relations]</p><div class="doc"><dl><dt><em>Theorem</em>.</dt><dd>
</dd></dl><p>As mentioned earlier, when looking at the proof of Theorem 2 in detail, one notices that further generalization
 is possible. Indeed, the presence of <code>R . cat</code> in Theorem 4 is superficial, and the theorem can still be
 generalized:
</p><pre>
 R   = U . (id <code>&gt;&lt;</code> S )    -- (RUS)
     = V . (T  <code>&gt;&lt;</code> id)    -- (RVT)
</pre><p>where
</p><pre>
     S . S&#176; . S = S        -- (S invertable)
     T . T&#176; . T = T        -- (T invertable)
</pre><p>imply
</p><pre>
 R   = R . (T&#176; <code>&gt;&lt;</code> S&#176;) . (T <code>&gt;&lt;</code> S)
</pre></div></div><div class="top"><p class="src"><a name="v:t07proof" class="def">t07proof</a> ::  theorem proof [t07] [on relations]</p><div class="doc"><dl><dt><em>Proof</em>:</dt><dd>
</dd></dl><pre>
                     R = U . (id x S)
  { S invertable }     = U . (id x S) . (id x S&#176;) . (id x S)
  { RUS, in reverse }  = R            . (id x S&#176;) . (id x S)
  { RVT }              = V . (T x id) . (id x S&#176;) . (id x S)
  { T&#176; T = id ? }      = V . (T x id) . (T&#176; x S&#176;) . (T x S)
  { RVT, in reverse }  = R            . (T&#176; x S&#176;) . (T x S)

{ done }           R = R . (T&#176; x S&#176;) . (T x S)
</pre></div></div><div class="top"><p class="src"><a name="v:t07comments" class="def">t07comments</a> ::  theorem comments [t07]</p><div class="doc"><dl><dt><em>Comments</em>:</dt><dd>
</dd></dl><p>However, the conclusion of the theorem, that:
</p><pre>R = R . (T&#176; x S&#176;) . (T x S)</pre><p>does not have much structure hinting at how this theorem can be useful. 
</p><p>The use cases we have found are when <code>S</code> is a sub-expression of <code>R</code> 
 (for example, to prove [<code><code><a href="Pearl-GaDtTLHT-Section03.html#v:t05">t05</a></code></code>], we used:
</p><pre> 
  R     = k&#176; . cat
  S = T = k&#176;
</pre><p>We do not require <code>S = T</code> in general. 
</p><p>We use Theorem 7 to establish recursive equations about <code>S</code>, hoping to 
 construct a terminating definition of <code>S</code>.
</p></div></div><div class="top"><p class="src"><a name="v:p11" class="def">p11</a> ::  property</p><div class="doc"><pre>
   (<code><a href="Pearl-GaDtTLHT-Section05.html#v:p11">p11</a></code>)   f . fill = U . ( id <code>&gt;&lt;</code> f ) &#8743;
</pre></div></div><div class="top"><p class="src"><a name="v:p12" class="def">p12</a> ::  property</p><div class="doc"><pre>
   (<code><a href="Pearl-GaDtTLHT-Section05.html#v:p12">p12</a></code>)   f . fill = V . ( f&#8242; <code>&gt;&lt;</code> id )
</pre></div></div><div class="top"><p class="src"><a name="v:test55" class="def">test55</a> ::  a</p></div><div class="top"><p class="src"><a name="v:p13" class="def">p13</a> ::  property</p><div class="doc"><pre>
   (<code><a href="Pearl-GaDtTLHT-Section05.html#v:p13">p13</a></code>)   fill&#176; . k = ( id <code>&gt;&lt;</code> k ) . mem . unfp&#8595; ( g&#8595;, f&#8595;, p )
</pre><p>By generating a tree &#8220;from the middle&#8221; we mean to find:
</p><pre>
     g  :: b -&gt; ( b, b )
     k&#8242; :: b -&gt;  Cxt a 
</pre><p>such that:
</p><pre>
 k v  | p v = L ( f&#8595; v )
      | ( v&#8593;, v&#8595; ) &lt;- g v = fill ( k' v&#8593; ) ( k v&#8595; )
</pre><p>That is, the tree returned by k, if not a leaf, can be split into a
 context and a subtree that can be generated separately from the two
 seeds returned by g. 
</p><p>It suffices for g and k'to satisfy:
</p><pre>
       fill&#176; . k = (k <code>&gt;&lt;</code> k ) . g
</pre><p>Generating a tree &#8220;upwards&#8221; intuitively means to start from a
 leaf and find the path back to the root. 
</p><p>With application of Theorem 7 in mind, we want to come up with a function:
</p><pre>
   unfp&#8593; ( g&#8593;, f&#8593; ) :: b -&gt; [( b, Tree a )]
</pre><p>that satisfies, for some k':
</p></div></div><div class="top"><p class="src"><a name="v:p14" class="def">p14</a> ::  property</p><div class="doc"><pre>
   (<code><a href="Pearl-GaDtTLHT-Section05.html#v:p14">p14</a></code>)   fill&#176; . k = ( k' <code>&gt;&lt;</code> id ) . mem . unfp&#8593; ( g&#8593;, f&#8593; )
</pre></div></div><h1 id="g:1">the current tree as the left child
</h1><h1 id="g:2"><code>v r</code> the seed for the right child
</h1><h1 id="g:3">and <code>v'</code> the seed going up. 
</h1><div class="top"><p class="src"><a name="v:p15" class="def">p15</a> ::  property</p><div class="doc"><pre>

(<code><a href="Pearl-GaDtTLHT-Section05.html#v:p15">p15</a></code>)   fill&#176; . k   = ( k' <code>&gt;&lt;</code> k ) . ( k'&#176; <code>&gt;&lt;</code> k&#176; ) . fill&#176; .k
         if        k   = unf&#8595; ( g&#8595;, f&#8595;, p ) = mem .  unf&#8593; ( g&#8593;, f&#8593; )
                   k'  = mem . cxt&#8593; g&#8593; v. 
</pre><p>To compute k &#8220;from the middle&#8221;, we may pick g to be a subset of 
</p><pre>
 ( k'&#176; <code>&gt;&lt;</code> k&#176;) . fill&#176; . k
</pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.11.0</p></div></body></html>